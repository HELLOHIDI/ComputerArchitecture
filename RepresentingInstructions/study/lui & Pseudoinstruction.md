## how to store a 32-bit Constant to a register

앞서 우리는 I-format을 통해서 기존에 5bits로는 표현하기 부족한 상수와 주소를 16비트로 표현이 가능하게 되었다. 
근데 만약 16비트도 부족하면 어떻게 해야 될까? 

## lui
> **lui : 명령어의 operand인 16비트 상수를 rt 레지스터의 왼쪽 16비트에 쓴다. rt 레지스터 오른쪽(lower)은 0x0000이 된다.**
형식 : lui rt constant(16비트)
**그 다음에 ori 연산자를 통해 뒤에 16비트를 더해주면 된다.**

```
ex) 0x007D0900을 표현하고 싶다 그러면
i) lui $s0 , 0x007D
앞쪽 16비트에 저장해준다.
0000 0000 0111 1101  || 0000 0000 0000 0000 

그 다음에 ori 연산자를 통해 뒤에 16비트를 더해주면 된다.
ii) ori $s0 0x0090
	0000 0000 0111 1101 0000 0000 0000 0000
ori	0000 0000 0000 0000 0000 0000 1001 0000
--------------------------------------------
	0000 0000 0111 1101 0000 0000 1001 0000 
```

## Psuedoinstruction(유사명령어)
> 유사 명령어: 기계어 명령어는 아닌데  assembly 명령어만 있는 명령어. 즉 programmer의 편의를 위해 존재한다!

### 1. li
> li rd imm : 상수를 바로 register로 이동
```
li $10 1
=> 컴퓨터에서는 ori $10, $0, 1로 인식한다.
```

### 2. addi 32bit
> 32비트는 한번에 할당불가능하기 때문에 out of range 발생후
1) lui -> 2) ori로 assemble 해준다
```
addi $t1 $0 0x7fffffff
=> out of range 이후
1) lui $t1 0x7fff
2) ori $t1 0xffff
를 통해서 완성시킨다
```
+)첫번째 lui값은 R1[at]에 저장되는데
R1: 임시 레지스터로 어셈블러가 임시로 필요할 때 사용하는 레지스터
그래서 사용자가 마음대로 값을 할당하면 의도치않게 값이 바뀔 수 있어서 사용하지 않는 것이 좋다.

